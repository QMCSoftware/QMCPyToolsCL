{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quasi-Monte Carlo Tools in OpenCL &amp; C","text":"<p>The <code>qmctoolscl</code> package provides a Python interface to tools in OpenCL and C for performing Quasi-Monte Carlo (QMC). Routines are written as OpenCL kernels. By replacing a few code snippets, these OpenCL kernels are automatically translated to C functions. Python functions provide access to both the OpenCL kernels and C functions in a unified interface. Code is available on GitHub. </p> <ul> <li>Quasi-Monte Carlo Tools in OpenCL &amp; C<ul> <li>Installation</li> <li>Setup for OpenCL vs C</li> <li>Lattice Sequences<ul> <li>linear order</li> <li>natural order</li> <li>Gray code order</li> <li>shift mod 1</li> </ul> </li> <li>Digital Net Base 2<ul> <li>LSB to MSB integer representations</li> <li>linear matrix scrambling (LMS)</li> <li>digital interlacing</li> <li>undo digital interlacing</li> <li>natural order</li> <li>Gray code order</li> <li>digital shift</li> <li>convert digits to doubles</li> <li>nested uniform scrambling</li> </ul> </li> <li>Generalized Digital Net<ul> <li>linear Matrix Scramble</li> <li>natural order</li> <li>digital shift</li> <li>digital permutation</li> <li>convert digits to doubles</li> <li>nested uniform scramble</li> <li>digital interlacing</li> <li>undo digital interlacing</li> <li>natural order with the same base</li> </ul> </li> <li>Fast Transforms<ul> <li>(inverse) fast Fourier transform</li> <li>fast Walsh-Hadamard transform</li> </ul> </li> </ul> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>For now, install from source via </p> <pre><code>git clone https://github.com/QMCSoftware/qmctoolscl.git\ncd qmctoolscl\npip install numpy\npip install -e . \n</code></pre> <p>To use OpenCL features, please install PyOpenCL. Commands used to install PyOpenCL on Linux, MacOS, and Windows for our automated tests can be found here. Note that Apple has deprecated support for OpenCL (see this post), but installation is still possible in many cases. If you cannot install PyOpenCL, the C backend to this package will still work independently. </p> Full Doctests for qmctoolscl"},{"location":"#setup-for-opencl-vs-c","title":"Setup for OpenCL vs C","text":"<p>Let's start by importing the relevant packages </p> <pre><code>&gt;&gt;&gt; import qmctoolscl\n&gt;&gt;&gt; import numpy as np\n</code></pre> <p>and seeding a random number generator used for reproducibility</p> <pre><code>&gt;&gt;&gt; rng = np.random.Generator(np.random.SFC64(7))\n</code></pre> <p>To use the C backend supply the following keyword arguments to function calls</p> <pre><code>&gt;&gt;&gt; kwargs = {\n...     \"backend\": \"C\",\n... }\n</code></pre> <p>To use the OpenCL backend supply the following keyword arguments to function calls</p> <pre><code>&gt;&gt;&gt; kwargs = {\n...     \"backend\": \"CL\",\n...     \"wait\": True, ## required for accurate timing\n...     \"global_size\": (2,2,2), ## global size \n... }\n</code></pre>"},{"location":"#lattice-sequences","title":"Lattice Sequences","text":""},{"location":"#linear-order","title":"linear order","text":"<pre><code>&gt;&gt;&gt; print(qmctoolscl.lat_gen_linear.__doc__)\nLattice points in linear order\n\nArgs:\n    r (np.uint64): replications\n    n (np.uint64): points\n    d (np.uint64): dimension\n    g (np.ndarray of np.uint64): pointer to generating vector of size r*d\n    x (np.ndarray of np.double): pointer to point storage of size r*n*d\n&gt;&gt;&gt; g = np.array([\n...     [1,433461,315689,441789,501101],\n...     [1,182667,469891,498753,110745]],\n...     dtype=np.uint64)\n&gt;&gt;&gt; r = np.uint64(g.shape[0]) \n&gt;&gt;&gt; n = np.uint64(8) \n&gt;&gt;&gt; d = np.uint64(g.shape[1])\n&gt;&gt;&gt; x = np.empty((r,n,d),dtype=np.float64)\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.lat_gen_linear(r,n,d,g,x,**kwargs)\n&gt;&gt;&gt; x\narray([[[0.   , 0.   , 0.   , 0.   , 0.   ],\n        [0.125, 0.625, 0.125, 0.625, 0.625],\n        [0.25 , 0.25 , 0.25 , 0.25 , 0.25 ],\n        [0.375, 0.875, 0.375, 0.875, 0.875],\n        [0.5  , 0.5  , 0.5  , 0.5  , 0.5  ],\n        [0.625, 0.125, 0.625, 0.125, 0.125],\n        [0.75 , 0.75 , 0.75 , 0.75 , 0.75 ],\n        [0.875, 0.375, 0.875, 0.375, 0.375]],\n\n       [[0.   , 0.   , 0.   , 0.   , 0.   ],\n        [0.125, 0.375, 0.375, 0.125, 0.125],\n        [0.25 , 0.75 , 0.75 , 0.25 , 0.25 ],\n        [0.375, 0.125, 0.125, 0.375, 0.375],\n        [0.5  , 0.5  , 0.5  , 0.5  , 0.5  ],\n        [0.625, 0.875, 0.875, 0.625, 0.625],\n        [0.75 , 0.25 , 0.25 , 0.75 , 0.75 ],\n        [0.875, 0.625, 0.625, 0.875, 0.875]]])\n</code></pre>"},{"location":"#natural-order","title":"natural order","text":"<pre><code>&gt;&gt;&gt; print(qmctoolscl.lat_gen_natural.__doc__)\nLattice points in natural order\n\nArgs:\n    r (np.uint64): replications\n    n (np.uint64): points\n    d (np.uint64): dimension\n    n_start (np.uint64): starting index in sequence\n    g (np.ndarray of np.uint64): pointer to generating vector of size r*d \n    x (np.ndarray of np.double): pointer to point storage of size r*n*d\n&gt;&gt;&gt; n_start = np.uint64(2)\n&gt;&gt;&gt; n = np.uint64(6) \n&gt;&gt;&gt; x = np.empty((r,n,d),dtype=np.float64)\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.lat_gen_natural(r,n,d,n_start,g,x,**kwargs)\n&gt;&gt;&gt; x\narray([[[0.25 , 0.25 , 0.25 , 0.25 , 0.25 ],\n        [0.75 , 0.75 , 0.75 , 0.75 , 0.75 ],\n        [0.125, 0.625, 0.125, 0.625, 0.625],\n        [0.625, 0.125, 0.625, 0.125, 0.125],\n        [0.375, 0.875, 0.375, 0.875, 0.875],\n        [0.875, 0.375, 0.875, 0.375, 0.375]],\n\n       [[0.25 , 0.75 , 0.75 , 0.25 , 0.25 ],\n        [0.75 , 0.25 , 0.25 , 0.75 , 0.75 ],\n        [0.125, 0.375, 0.375, 0.125, 0.125],\n        [0.625, 0.875, 0.875, 0.625, 0.625],\n        [0.375, 0.125, 0.125, 0.375, 0.375],\n        [0.875, 0.625, 0.625, 0.875, 0.875]]])\n</code></pre>"},{"location":"#gray-code-order","title":"Gray code order","text":"<pre><code>&gt;&gt;&gt; print(qmctoolscl.lat_gen_gray.__doc__)\nLattice points in Gray code order\n\nArgs:\n    r (np.uint64): replications\n    n (np.uint64): points\n    d (np.uint64): dimension\n    n_start (np.uint64): starting index in sequence\n    g (np.ndarray of np.uint64): pointer to generating vector of size r*d \n    x (np.ndarray of np.double): pointer to point storage of size r*n*d\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.lat_gen_gray(r,n,d,n_start,g,x,**kwargs)\n&gt;&gt;&gt; x\narray([[[0.75 , 0.75 , 0.75 , 0.75 , 0.75 ],\n        [0.25 , 0.25 , 0.25 , 0.25 , 0.25 ],\n        [0.375, 0.875, 0.375, 0.875, 0.875],\n        [0.875, 0.375, 0.875, 0.375, 0.375],\n        [0.625, 0.125, 0.625, 0.125, 0.125],\n        [0.125, 0.625, 0.125, 0.625, 0.625]],\n\n       [[0.75 , 0.25 , 0.25 , 0.75 , 0.75 ],\n        [0.25 , 0.75 , 0.75 , 0.25 , 0.25 ],\n        [0.375, 0.125, 0.125, 0.375, 0.375],\n        [0.875, 0.625, 0.625, 0.875, 0.875],\n        [0.625, 0.875, 0.875, 0.625, 0.625],\n        [0.125, 0.375, 0.375, 0.125, 0.125]]])\n</code></pre>"},{"location":"#shift-mod-1","title":"shift mod 1","text":"<pre><code>&gt;&gt;&gt; print(qmctoolscl.lat_shift_mod_1.__doc__)\nShift mod 1 for lattice points\n\nArgs:\n    r (np.uint64): replications\n    n (np.uint64): points\n    d (np.uint64): dimension\n    r_x (np.uint64): replications in x\n    x (np.ndarray of np.double): lattice points of size r_x*n*d\n    shifts (np.ndarray of np.double): shifts of size r*d\n    xr (np.ndarray of np.double): pointer to point storage of size r*n*d\n&gt;&gt;&gt; r_x = r \n&gt;&gt;&gt; r = np.uint64(2*r_x)\n&gt;&gt;&gt; shifts = rng.random((r,d))\n&gt;&gt;&gt; xr = np.empty((r,n,d),dtype=np.float64)\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.lat_shift_mod_1(r,n,d,r_x,x,shifts,xr,**kwargs)\n&gt;&gt;&gt; xr\narray([[[0.79386058, 0.33727432, 0.1191824 , 0.40212985, 0.44669968],\n        [0.29386058, 0.83727432, 0.6191824 , 0.90212985, 0.94669968],\n        [0.41886058, 0.46227432, 0.7441824 , 0.52712985, 0.57169968],\n        [0.91886058, 0.96227432, 0.2441824 , 0.02712985, 0.07169968],\n        [0.66886058, 0.71227432, 0.9941824 , 0.77712985, 0.82169968],\n        [0.16886058, 0.21227432, 0.4941824 , 0.27712985, 0.32169968]],\n\n       [[0.85605352, 0.88025643, 0.38630282, 0.3468363 , 0.8076251 ],\n        [0.35605352, 0.38025643, 0.88630282, 0.8468363 , 0.3076251 ],\n        [0.48105352, 0.75525643, 0.26130282, 0.9718363 , 0.4326251 ],\n        [0.98105352, 0.25525643, 0.76130282, 0.4718363 , 0.9326251 ],\n        [0.73105352, 0.50525643, 0.01130282, 0.2218363 , 0.6826251 ],\n        [0.23105352, 0.00525643, 0.51130282, 0.7218363 , 0.1826251 ]],\n\n       [[0.9528797 , 0.97909681, 0.8866783 , 0.50220658, 0.59501765],\n        [0.4528797 , 0.47909681, 0.3866783 , 0.00220658, 0.09501765],\n        [0.5778797 , 0.10409681, 0.5116783 , 0.62720658, 0.72001765],\n        [0.0778797 , 0.60409681, 0.0116783 , 0.12720658, 0.22001765],\n        [0.8278797 , 0.35409681, 0.7616783 , 0.87720658, 0.97001765],\n        [0.3278797 , 0.85409681, 0.2616783 , 0.37720658, 0.47001765]],\n\n       [[0.31269008, 0.29826852, 0.96308655, 0.55983568, 0.60383675],\n        [0.81269008, 0.79826852, 0.46308655, 0.05983568, 0.10383675],\n        [0.93769008, 0.17326852, 0.83808655, 0.18483568, 0.22883675],\n        [0.43769008, 0.67326852, 0.33808655, 0.68483568, 0.72883675],\n        [0.18769008, 0.92326852, 0.58808655, 0.43483568, 0.47883675],\n        [0.68769008, 0.42326852, 0.08808655, 0.93483568, 0.97883675]]])\n</code></pre>"},{"location":"#digital-net-base-2","title":"Digital Net Base 2","text":""},{"location":"#lsb-to-msb-integer-representations","title":"LSB to MSB integer representations","text":"<p>convert generating matrices from least significant bit (LSB) order to most significant bit (MSB) order</p> <pre><code>&gt;&gt;&gt; print(qmctoolscl.dnb2_gmat_lsb_to_msb.__doc__)\nConvert base 2 generating matrices with integers stored in Least Significant Bit order to Most Significant Bit order\n\nArgs:\n    r (np.uint64): replications\n    d (np.uint64): dimension\n    mmax (np.uint64): columns in each generating matrix \n    tmaxes (np.ndarray of np.uint64): length r vector of bits in each integer of the resulting MSB generating matrices\n    C_lsb (np.ndarray of np.uint64): original generating matrices of size r*d*mmax\n    C_msb (np.ndarray of np.uint64): new generating matrices of size r*d*mmax\n&gt;&gt;&gt; C_lsb = np.array([\n...     [1,2,4,8],\n...     [1,3,5,15],\n...     [1,3,6,9],\n...     [1,3,4,10]],\n...     dtype=np.uint64)\n&gt;&gt;&gt; r = np.uint64(1)\n&gt;&gt;&gt; d = np.uint64(C_lsb.shape[0])\n&gt;&gt;&gt; mmax = np.uint64(C_lsb.shape[1])\n&gt;&gt;&gt; tmax = 4\n&gt;&gt;&gt; tmaxes = np.tile(np.uint64(tmax),int(r))\n&gt;&gt;&gt; C = np.empty((d,mmax),dtype=np.uint64)\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.dnb2_gmat_lsb_to_msb(r,d,mmax,tmaxes,C_lsb,C,**kwargs)\n&gt;&gt;&gt; C\narray([[ 8,  4,  2,  1],\n       [ 8, 12, 10, 15],\n       [ 8, 12,  6,  9],\n       [ 8, 12,  2,  5]], dtype=uint64)\n</code></pre>"},{"location":"#linear-matrix-scrambling-lms","title":"linear matrix scrambling (LMS)","text":"<pre><code>&gt;&gt;&gt; print(qmctoolscl.dnb2_linear_matrix_scramble.__doc__)\nLinear matrix scrambling for base 2 generating matrices\n\nArgs:\n    r (np.uint64): replications\n    d (np.uint64): dimension\n    mmax (np.uint64): columns in each generating matrix \n    r_C (np.uint64): original generating matrices\n    tmax_new (np.uint64): bits in the integers of the resulting generating matrices\n    S (np.ndarray of np.uint64): scrambling matrices of size r*d*tmax_new\n    C (np.ndarray of np.uint64): original generating matrices of size r_C*d*mmax\n    C_lms (np.ndarray of np.uint64): resulting generating matrices of size r*d*mmax\n&gt;&gt;&gt; r_C = r \n&gt;&gt;&gt; r = np.uint64(2*r_C)\n&gt;&gt;&gt; tmax_new = np.uint64(6)\n&gt;&gt;&gt; print(qmctoolscl.dnb2_get_linear_scramble_matrix.__doc__)\nReturn a scrambling matrix for linear matrix scrambling\n\nArgs:\n    rng (np.random._generator.Generator): random number generator\n    r (np.uint64): replications\n    d (np.uint64): dimension\n    tmax (np.uint64): bits in each integer\n    tmax_new (np.uint64): bits in each integer of the generating matrix after scrambling\n    print_mats (np.uint8): flag to print the resulting matrices\n&gt;&gt;&gt; print_mats = np.uint8(True)\n&gt;&gt;&gt; S = qmctoolscl.dnb2_get_linear_scramble_matrix(rng,r,d,tmax,tmax_new,print_mats)\nS with shape (r=2, d=4, tmax_new=6)\nl = 0\n    j = 0\n        1000\n        1100\n        1010\n        1011\n        0000\n        1011\n    j = 1\n        1000\n        1100\n        1010\n        1111\n        0101\n        0111\n    j = 2\n        1000\n        0100\n        0010\n        1001\n        0001\n        0111\n    j = 3\n        1000\n        1100\n        1010\n        1001\n        0010\n        0010\nl = 1\n    j = 0\n        1000\n        0100\n        0010\n        0101\n        1101\n        1000\n    j = 1\n        1000\n        0100\n        0110\n        1001\n        1010\n        1001\n    j = 2\n        1000\n        0100\n        0110\n        0111\n        1101\n        1110\n    j = 3\n        1000\n        0100\n        0110\n        0011\n        1000\n        0000\n&gt;&gt;&gt; C_lms = np.empty((r,d,mmax),dtype=np.uint64)\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.dnb2_linear_matrix_scramble(r,d,mmax,r_C,tmax_new,S,C,C_lms,**kwargs)\n&gt;&gt;&gt; C_lms\narray([[[61, 16, 13,  5],\n        [60, 43, 49, 33],\n        [36, 53, 24, 35],\n        [60, 44, 11, 20]],\n\n       [[35, 22,  8,  6],\n        [39, 63, 45, 48],\n        [35, 60, 18, 37],\n        [34, 58, 12, 28]]], dtype=uint64)\n</code></pre>"},{"location":"#digital-interlacing","title":"digital interlacing","text":"<p>Digital interlacing is used to create higher order digital nets.</p> <pre><code>&gt;&gt;&gt; print(qmctoolscl.dnb2_interlace.__doc__)\nInterlace generating matrices or transpose of point sets to attain higher order digital nets in base 2\n\nArgs:\n    r (np.uint64): replications\n    d_alpha (np.uint64): dimension of resulting generating matrices \n    mmax (np.uint64): columns of generating matrices\n    d (np.uint64): dimension of original generating matrices\n    tmax (np.uint64): bits in integers of original generating matrices\n    tmax_alpha (np.uint64): bits in integers of resulting generating matrices\n    alpha (np.uint64): interlacing factor\n    C (np.ndarray of np.uint64): original generating matrices of size r*d*mmax\n    C_alpha (np.ndarray of np.uint64): resulting interlaced generating matrices of size r*d_alpha*mmax\n&gt;&gt;&gt; alpha = np.uint64(2) \n&gt;&gt;&gt; d_alpha = np.uint64(d//alpha)\n&gt;&gt;&gt; tmax = tmax_new\n&gt;&gt;&gt; tmax_alpha = min(alpha*tmax_new,64)\n&gt;&gt;&gt; C_alpha = np.empty((r,d_alpha,mmax),dtype=np.uint64)\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.dnb2_interlace(r,d_alpha,mmax,d,tmax,tmax_alpha,alpha,C_lms,C_alpha,**kwargs)\n&gt;&gt;&gt; C_alpha\narray([[[4082, 1605, 1443, 1059],\n        [3440, 3698,  709, 2330]],\n\n       [[3103, 1917, 1233, 1320],\n        [3086, 4068,  600, 2418]]], dtype=uint64)\n</code></pre>"},{"location":"#undo-digital-interlacing","title":"undo digital interlacing","text":"<pre><code>&gt;&gt;&gt; print(qmctoolscl.dnb2_undo_interlace.__doc__)\nUndo interlacing of generating matrices in base 2\n\nArgs:\n    r (np.uint64): replications\n    d (np.uint64): dimension of resulting generating matrices \n    mmax (np.uint64): columns in generating matrices\n    d_alpha (np.uint64): dimension of interlaced generating matrices\n    tmax (np.uint64): bits in integers of original generating matrices \n    tmax_alpha (np.uint64): bits in integers of interlaced generating matrices\n    alpha (np.uint64): interlacing factor\n    C_alpha (np.ndarray of np.uint64): interlaced generating matrices of size r*d_alpha*mmax\n    C (np.ndarray of np.uint64): original generating matrices of size r*d*mmax\n&gt;&gt;&gt; C_lms_cp = np.empty((r,d,mmax),dtype=np.uint64)\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.dnb2_undo_interlace(r,d,mmax,d_alpha,tmax,tmax_alpha,alpha,C_alpha,C_lms_cp,**kwargs)\n&gt;&gt;&gt; print((C_lms_cp==C_lms).all())\nTrue\n</code></pre>"},{"location":"#natural-order_1","title":"natural order","text":"<pre><code>&gt;&gt;&gt; print(qmctoolscl.dnb2_gen_natural.__doc__)\nBinary representation of digital net in base 2 in natural order\n\nArgs:\n    r (np.uint64): replications\n    n (np.uint64): points\n    d (np.uint64): dimension\n    n_start (np.uint64): starting index in sequence\n    mmax (np.uint64): columns in each generating matrix\n    C (np.ndarray of np.uint64): generating matrices of size r*d*mmax\n    xb (np.ndarray of np.uint64): binary digital net points of size r*n*d\n&gt;&gt;&gt; C = C_alpha\n&gt;&gt;&gt; d = d_alpha\n&gt;&gt;&gt; n_start = np.uint64(2)\n&gt;&gt;&gt; n = np.uint64(14)\n&gt;&gt;&gt; xb = np.empty((r,n,d),dtype=np.uint64)\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.dnb2_gen_natural(r,n,d,n_start,mmax,C,xb,**kwargs)\n&gt;&gt;&gt; xb\narray([[[1605, 3698],\n        [2487,  770],\n        [1443,  709],\n        [2641, 4021],\n        [ 998, 3255],\n        [3092,  455],\n        [1059, 2330],\n        [3025, 1130],\n        [ 614, 1896],\n        [3476, 2584],\n        [ 384, 3039],\n        [3698, 1711],\n        [1989, 1453],\n        [2103, 2269]],\n\n       [[1917, 4068],\n        [2914, 1002],\n        [1233,  600],\n        [2254, 3670],\n        [ 940, 3516],\n        [4019,  434],\n        [1320, 2418],\n        [2359, 1404],\n        [ 597, 1686],\n        [3658, 2712],\n        [ 505, 2858],\n        [3558, 1828],\n        [1668, 1230],\n        [2715, 2240]]], dtype=uint64)\n</code></pre>"},{"location":"#gray-code-order_1","title":"Gray code order","text":"<pre><code>&gt;&gt;&gt; print(qmctoolscl.dnb2_gen_gray.__doc__)\nBinary representation of digital net in base 2 in Gray code order\n\nArgs:\n    r (np.uint64): replications\n    n (np.uint64): points\n    d (np.uint64): dimension\n    n_start (np.uint64): starting index in sequence\n    mmax (np.uint64): columns in each generating matrix\n    C (np.ndarray of np.uint64): generating matrices of size r*d*mmax\n    xb (np.ndarray of np.uint64): binary digital net points of size r*n*d\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.dnb2_gen_gray(r,n,d,n_start,mmax,C,xb,**kwargs)\n&gt;&gt;&gt; xb\narray([[[2487,  770],\n        [1605, 3698],\n        [ 998, 3255],\n        [3092,  455],\n        [2641, 4021],\n        [1443,  709],\n        [ 384, 3039],\n        [3698, 1711],\n        [2103, 2269],\n        [1989, 1453],\n        [ 614, 1896],\n        [3476, 2584],\n        [3025, 1130],\n        [1059, 2330]],\n\n       [[2914, 1002],\n        [1917, 4068],\n        [ 940, 3516],\n        [4019,  434],\n        [2254, 3670],\n        [1233,  600],\n        [ 505, 2858],\n        [3558, 1828],\n        [2715, 2240],\n        [1668, 1230],\n        [ 597, 1686],\n        [3658, 2712],\n        [2359, 1404],\n        [1320, 2418]]], dtype=uint64)\n</code></pre>"},{"location":"#digital-shift","title":"digital shift","text":"<pre><code>&gt;&gt;&gt; print(qmctoolscl.dnb2_digital_shift.__doc__)\nDigital shift base 2 digital net\n\nArgs:\n    r (np.uint64): replications\n    n (np.uint64): points\n    d (np.uint64): dimension\n    r_x (np.uint64): replications of xb\n    lshifts (np.ndarray of np.uint64): left shift applied to each element of xb\n    xb (np.ndarray of np.uint64): binary base 2 digital net points of size r_x*n*d\n    shiftsb (np.ndarray of np.uint64): digital shifts of size r*d\n    xrb (np.ndarray of np.uint64): digital shifted digital net points of size r*n*d\n&gt;&gt;&gt; tmax = tmax_alpha \n&gt;&gt;&gt; tmax_new = np.uint64(64)\n&gt;&gt;&gt; lshifts = np.tile(tmax_new-tmax,int(r)) \n&gt;&gt;&gt; r_x = r \n&gt;&gt;&gt; r = np.uint64(2*r_x)\n&gt;&gt;&gt; print(qmctoolscl.random_tbit_uint64s.__doc__)\nGenerate the desired shape of random integers with t bits\n\nArgs:\n    rng (np.random._generator.Generator): random number generator\n    t: (int): number of bits with 0 &lt;= t &lt;= 64\n    shape (tuple of ints): shape of resulting integer array\n&gt;&gt;&gt; shiftsb = qmctoolscl.random_tbit_uint64s(rng,tmax_new,(r,d))\n&gt;&gt;&gt; shiftsb\narray([[ 5310653692329262186, 13368902947290702765],\n       [14338104955770306630,   858526716083693676],\n       [ 8506091904275275003, 16209688535125722604],\n       [17447177601860792486,  9021077006476608718]], dtype=uint64)\n&gt;&gt;&gt; xrb = np.empty((r,n,d),dtype=np.uint64)\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.dnb2_digital_shift(r,n,d,r_x,lshifts,xb,shiftsb,xrb,**kwargs)\n&gt;&gt;&gt; xrb\narray([[[15187047675152759914,  9919145632724902829],\n        [ 3306551858149391466,  6820669089094001581],\n        [ 8634310217328688234,  8284338967989412781],\n        [ 9868296515228204138, 11959276263923737517],\n        [17051537920884145258,  4816567254914130861],\n        [ 1406032815399042154, 10797347560062149549],\n        [ 5887114444632685674,   321974826798375853],\n        [12579463490905242730, 15237896792649458605],\n        [14610586922849336426,  3771732141364175789],\n        [ 3883012610452814954, 16381811098001564589],\n        [ 8057849465025264746, 14918141219106153389],\n        [10444757267531627626,  1731601510165341101],\n        [17627998673187568746, 18385912932181435309],\n        [  829572063095618666,  2893530214026929069]],\n\n       [[ 8132144669253763142,  3839909669402962028],\n        [12766348685818003526, 17701989322449348716],\n        [18175171838289969222, 14999829546027051116],\n        [ 4452703773692067910,  1209807487018592364],\n        [ 5339912900284055622, 17188578964929112172],\n        [10082203307905187910,  3344513710392207468],\n        [15666666845844602950, 13351512082409449580],\n        [ 1773061995406622790,  8766847661746284652],\n        [ 8019554678569500742,  9793668376786757740],\n        [12590708300350554182,  5118931963576182892],\n        [16405257184733364294,  7100515799619201132],\n        [ 2475623537276420166, 11703194618791848044],\n        [ 6164071632092856390,  6641148637627410540],\n        [10699196456854945862, 11297870652328503404]],\n\n       [[17112470792180292859, 15047759831264134636],\n        [ 1322850498619333883,   564183429640619500],\n        [ 5218464176294812923,  3135738816869172716],\n        [13207849915250072827, 18195775970796111340],\n        [15211951749429943547,  1991824511517066732],\n        [ 3187340744350719227, 14746018656230311404],\n        [ 7929631151971851515,  6702589721746605548],\n        [10460654142554070267,  9945181453453362668],\n        [17688931544483716347,  7864518425608193516],\n        [  746389746315910395, 13412953166528644588],\n        [ 5794924928598236411, 10841397779300091372],\n        [12631389162946649339,  4716502286076216812],\n        [14635490997126520059, 11985312084652197356],\n        [ 3763801496654142715,  8166259600642016748]],\n\n       [[ 4900149040006590630,  4868758150041011406],\n        [ 9651446646882463910,  9471436969213658318],\n        [14474801847796265126, 12029481557560100046],\n        [  653254591396212902,  7354745144349525198],\n        [ 9133532689734856870, 10975639244755403982],\n        [13776743905553838246,  6390974824092239054],\n        [17127422028317487270, 14956821315350922446],\n        [ 3188781181605802150,  1112756060814017742],\n        [ 6598006099525267622, 17379757914876249294],\n        [11124123725032616102,  3589735855867790542],\n        [15524140560973590694,  1464036831748916430],\n        [ 1621528511280869542, 15326116484795303118],\n        [ 7012337265243353254,  3094339896857035982],\n        [11574483687769665702, 16866347557356012750]]], dtype=uint64)\n</code></pre>"},{"location":"#convert-digits-to-doubles","title":"convert digits to doubles","text":"<pre><code>&gt;&gt;&gt; print(qmctoolscl.dnb2_integer_to_float.__doc__)\nConvert base 2 binary digital net points to floats\n\nArgs:\n    r (np.uint64): replications\n    n (np.uint64): points\n    d (np.uint64): dimension\n    tmaxes (np.ndarray of np.uint64): bits in integers of each generating matrix of size r\n    xb (np.ndarray of np.uint64): binary digital net points of size r*n*d\n    x (np.ndarray of np.double): float digital net points of size r*n*d\n&gt;&gt;&gt; x = np.empty((r,n,d),dtype=np.float64)\n&gt;&gt;&gt; tmaxes_new = np.tile(tmax_new,int(r))\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.dnb2_integer_to_float(r,n,d,tmaxes_new,xrb,x,**kwargs)\n&gt;&gt;&gt; x\narray([[[0.8232915 , 0.53771796],\n        [0.17924854, 0.36974921],\n        [0.46806689, 0.44909492],\n        [0.53496143, 0.64831367],\n        [0.92436572, 0.26110663],\n        [0.07622119, 0.58532538],\n        [0.31914111, 0.01745429],\n        [0.68193408, 0.82604804],\n        [0.7920415 , 0.20446601],\n        [0.21049854, 0.88805976],\n        [0.43681689, 0.80871406],\n        [0.56621143, 0.09387031],\n        [0.95561572, 0.99670234],\n        [0.04497119, 0.15685859]],\n\n       [[0.44084445, 0.20816192],\n        [0.69206515, 0.95962676],\n        [0.98527804, 0.81314239],\n        [0.24138156, 0.0655838 ],\n        [0.28947726, 0.93179473],\n        [0.54655734, 0.18130645],\n        [0.84929171, 0.72378692],\n        [0.09611788, 0.47525176],\n        [0.43474093, 0.53091583],\n        [0.68254366, 0.27749786],\n        [0.88933077, 0.38491973],\n        [0.13420382, 0.63443145],\n        [0.33415499, 0.36001739],\n        [0.5800046 , 0.6124588 ]],\n\n       [[0.9276689 , 0.8157407 ],\n        [0.07171187, 0.03058445],\n        [0.28289351, 0.16998874],\n        [0.71599898, 0.98639499],\n        [0.82464156, 0.10797702],\n        [0.17278609, 0.79938327],\n        [0.42986617, 0.36334812],\n        [0.5670732 , 0.53912937],\n        [0.9589189 , 0.4263364 ],\n        [0.04046187, 0.72711765],\n        [0.31414351, 0.58771335],\n        [0.68474898, 0.2556821 ],\n        [0.79339156, 0.64972507],\n        [0.20403609, 0.44269382]],\n\n       [[0.26563761, 0.26393591],\n        [0.52320597, 0.51344763],\n        [0.78468058, 0.6521195 ],\n        [0.035413  , 0.39870153],\n        [0.4951298 , 0.5949906 ],\n        [0.74683878, 0.34645544],\n        [0.92847941, 0.81081091],\n        [0.17286417, 0.06032263],\n        [0.35767863, 0.94215856],\n        [0.60303996, 0.19459997],\n        [0.84156535, 0.0793656 ],\n        [0.08790324, 0.83083044],\n        [0.38013956, 0.1677445 ],\n        [0.62745402, 0.91432653]]])\n</code></pre>"},{"location":"#nested-uniform-scrambling","title":"nested uniform scrambling","text":"<pre><code>&gt;&gt;&gt; r = np.uint64(1) \n&gt;&gt;&gt; n_start = np.uint64(0)\n&gt;&gt;&gt; n = np.uint64(8)\n&gt;&gt;&gt; d = np.uint64(4)\n&gt;&gt;&gt; C = np.array([\n...   [ 8,  4,  2,  1],\n...   [ 8, 12, 10, 15],\n...   [ 8, 12,  6,  9],\n...   [ 8, 12,  2,  5]], \n...   dtype=np.uint64)\n&gt;&gt;&gt; mmax = np.uint64(C.shape[1])\n&gt;&gt;&gt; tmax = np.uint64(np.ceil(np.log2(np.max(C))))\n&gt;&gt;&gt; xb = np.empty((r,n,d),dtype=np.uint64)\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.dnb2_gen_natural(r,n,d,n_start,mmax,C,xb,**kwargs)\n&gt;&gt;&gt; print(qmctoolscl.dnb2_nested_uniform_scramble.__doc__)\nNested uniform scramble of digital net b2\n\nArgs: \n    r (np.uint64): replications \n    n (np.uint64): points\n    d (np.uint64): dimensions\n    r_x (np.uint64): replications of xb\n    tmax (np.uint64): maximum number of bits in each integer\n    tmax_new (np.uint64): maximum number of bits in each integer after scrambling\n    rngs (np.ndarray of numpy.random._generator.Generator): random number generators of size r*d\n    root_nodes (np.ndarray of NUSNode_dnb2): root nodes of size r*d\n    xb (np.ndarray of np.uint64): array of unrandomized points of size r*n*d\n    xrb (np.ndarray of np.uint64): array to store scrambled points of size r*n*d\n&gt;&gt;&gt; tmax_new = np.uint64(2*tmax) \n&gt;&gt;&gt; r_x = r\n&gt;&gt;&gt; r = np.uint64(2*r_x)\n&gt;&gt;&gt; base_seed_seq = np.random.SeedSequence(7)\n&gt;&gt;&gt; seeds = base_seed_seq.spawn(r*d)\n&gt;&gt;&gt; rngs = np.array([np.random.Generator(np.random.SFC64(seed)) for seed in seeds]).reshape(r,d)\n&gt;&gt;&gt; root_nodes = np.array([qmctoolscl.NUSNode_dnb2() for i in range(r*d)]).reshape(r,d)\n&gt;&gt;&gt; xrb = np.zeros((r,n,d),dtype=np.uint64)\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.dnb2_nested_uniform_scramble(r,n,d,r_x,tmax,tmax_new,rngs,root_nodes,xb,xrb)\n&gt;&gt;&gt; xrb\narray([[[ 94,  54, 235,  30],\n        [174, 243,  26, 129],\n        [ 30, 172,  85, 222],\n        [254, 127, 143,  68],\n        [ 96, 207, 171,  46],\n        [131,  21, 125, 165],\n        [ 38,  79,  47, 237],\n        [199, 133, 199,  99]],\n\n       [[ 37, 152, 170, 143],\n        [219,  56,  68,  29],\n        [ 65,  98,  34, 111],\n        [181, 211, 196, 220],\n        [ 26,   9, 242, 180],\n        [245, 167,   2,  42],\n        [116, 225, 105,  93],\n        [138,  93, 139, 230]]], dtype=uint64)\n</code></pre>"},{"location":"#generalized-digital-net","title":"Generalized Digital Net","text":"<p>Accommodates both Halton sequences and digital nets in any prime base</p>"},{"location":"#linear-matrix-scramble","title":"linear Matrix Scramble","text":"<pre><code>&gt;&gt;&gt; print(qmctoolscl.gdn_linear_matrix_scramble.__doc__)\nLinear matrix scramble for generalized digital net\n\nArgs:\n    r (np.uint64): replications \n    d (np.uint64): dimension \n    mmax (np.uint64): columns in each generating matrix\n    r_C (np.uint64): number of replications of C \n    r_b (np.uint64): number of replications of bases\n    tmax (np.uint64): number of rows in each generating matrix \n    tmax_new (np.uint64): new number of rows in each generating matrix \n    bases (np.ndarray of np.uint64): bases for each dimension of size r*d \n    S (np.ndarray of np.uint64): scramble matrices of size r*d*tmax_new*tmax\n    C (np.ndarray of np.uint64): generating matrices of size r_C*d*mmax*tmax \n    C_lms (np.ndarray of np.uint64): new generating matrices of size r*d*mmax*tmax_new\n&gt;&gt;&gt; bases = np.array([[2,3],[5,7]],dtype=np.uint64)\n&gt;&gt;&gt; r_C = r_b = np.uint64(bases.shape[0])\n&gt;&gt;&gt; d = np.uint64(bases.shape[1]) \n&gt;&gt;&gt; mmax = np.uint64(5)\n&gt;&gt;&gt; tmax = mmax\n&gt;&gt;&gt; print(qmctoolscl.gdn_get_halton_generating_matrix.__doc__)\nReturn the identity matrices comprising the Halton generating matrices\n\nArg:\n    r (np.uint64): replications \n    d (np.uint64): dimension \n    mmax (np.uint64): maximum number rows and columns in each generating matrix\n&gt;&gt;&gt; C = qmctoolscl.gdn_get_halton_generating_matrix(r_C,d,mmax)\n&gt;&gt;&gt; tmax_new = np.uint64(2*tmax)\n&gt;&gt;&gt; r = np.uint64(2*r_C)\n&gt;&gt;&gt; print(qmctoolscl.gdn_get_linear_scramble_matrix.__doc__)\nReturn a scrambling matrix for linear matrix scrambling\n\nArgs:\n    rng (np.random._generator.Generator): random number generator\n    r (np.uint64): replications\n    d (np.uint64): dimension\n    tmax (np.uint64): bits in each integer\n    tmax_new (np.uint64): bits in each integer of the generating matrix after scrambling\n    r_b (np.uint64): replications of bases \n    bases (np.ndarray of np.uint64): bases of size r_b*d\n&gt;&gt;&gt; S = qmctoolscl.gdn_get_linear_scramble_matrix(rng,r,d,tmax,tmax_new,r_b,bases)\n&gt;&gt;&gt; S\narray([[[[1, 0, 0, 0, 0],\n         [1, 1, 0, 0, 0],\n         [0, 0, 1, 0, 0],\n         [0, 0, 0, 1, 0],\n         [1, 0, 0, 0, 1],\n         [1, 0, 0, 0, 0],\n         [0, 1, 0, 0, 0],\n         [1, 0, 0, 1, 1],\n         [1, 0, 1, 0, 1],\n         [1, 1, 0, 1, 0]],\n\n        [[2, 0, 0, 0, 0],\n         [0, 1, 0, 0, 0],\n         [1, 0, 1, 0, 0],\n         [2, 0, 1, 2, 0],\n         [2, 1, 1, 0, 1],\n         [2, 0, 2, 2, 0],\n         [2, 2, 1, 0, 2],\n         [2, 0, 2, 0, 1],\n         [0, 2, 2, 0, 1],\n         [2, 0, 0, 1, 0]]],\n\n\n       [[[3, 0, 0, 0, 0],\n         [1, 1, 0, 0, 0],\n         [4, 2, 4, 0, 0],\n         [4, 2, 1, 2, 0],\n         [3, 4, 4, 3, 1],\n         [3, 3, 1, 1, 4],\n         [2, 2, 0, 4, 2],\n         [3, 3, 3, 1, 3],\n         [3, 3, 1, 2, 0],\n         [4, 3, 1, 1, 0]],\n\n        [[3, 0, 0, 0, 0],\n         [6, 1, 0, 0, 0],\n         [1, 0, 2, 0, 0],\n         [1, 4, 4, 1, 0],\n         [4, 4, 1, 2, 1],\n         [3, 4, 1, 6, 5],\n         [1, 3, 5, 1, 5],\n         [2, 0, 4, 3, 1],\n         [4, 0, 0, 1, 3],\n         [6, 0, 4, 3, 6]]],\n\n\n       [[[1, 0, 0, 0, 0],\n         [1, 1, 0, 0, 0],\n         [1, 1, 1, 0, 0],\n         [0, 1, 0, 1, 0],\n         [0, 0, 0, 1, 1],\n         [1, 0, 0, 0, 0],\n         [1, 0, 0, 0, 1],\n         [1, 1, 0, 0, 0],\n         [1, 0, 0, 1, 1],\n         [1, 0, 1, 1, 1]],\n\n        [[1, 0, 0, 0, 0],\n         [2, 1, 0, 0, 0],\n         [2, 1, 2, 0, 0],\n         [0, 0, 1, 1, 0],\n         [2, 2, 2, 1, 1],\n         [1, 1, 2, 2, 0],\n         [2, 1, 0, 2, 2],\n         [0, 0, 2, 0, 2],\n         [2, 1, 0, 2, 0],\n         [2, 0, 1, 0, 2]]],\n\n\n       [[[2, 0, 0, 0, 0],\n         [1, 4, 0, 0, 0],\n         [1, 3, 3, 0, 0],\n         [1, 3, 1, 1, 0],\n         [1, 3, 1, 1, 4],\n         [0, 2, 3, 3, 0],\n         [1, 3, 3, 3, 4],\n         [4, 1, 2, 4, 2],\n         [1, 4, 0, 1, 3],\n         [1, 3, 3, 1, 4]],\n\n        [[3, 0, 0, 0, 0],\n         [1, 5, 0, 0, 0],\n         [5, 2, 6, 0, 0],\n         [1, 4, 4, 4, 0],\n         [4, 3, 4, 6, 3],\n         [5, 6, 6, 1, 3],\n         [1, 1, 5, 2, 3],\n         [5, 6, 0, 3, 6],\n         [0, 2, 5, 5, 6],\n         [1, 1, 1, 2, 0]]]], dtype=uint64)\n&gt;&gt;&gt; C_lms = np.empty((r,d,mmax,tmax_new),dtype=np.uint64)\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.gdn_linear_matrix_scramble(r,d,mmax,r_C,r_b,tmax,tmax_new,bases,S,C,C_lms,**kwargs)\n&gt;&gt;&gt; C_lms \narray([[[[1, 1, 0, 0, 1, 1, 0, 1, 1, 1],\n         [0, 1, 0, 0, 0, 0, 1, 0, 0, 1],\n         [0, 0, 1, 0, 0, 0, 0, 0, 1, 0],\n         [0, 0, 0, 1, 0, 0, 0, 1, 0, 1],\n         [0, 0, 0, 0, 1, 0, 0, 1, 1, 0]],\n\n        [[2, 0, 1, 2, 2, 2, 2, 2, 0, 2],\n         [0, 1, 0, 0, 1, 0, 2, 0, 2, 0],\n         [0, 0, 1, 1, 1, 2, 1, 2, 2, 0],\n         [0, 0, 0, 2, 0, 2, 0, 0, 0, 1],\n         [0, 0, 0, 0, 1, 0, 2, 1, 1, 0]]],\n\n\n       [[[3, 1, 4, 4, 3, 3, 2, 3, 3, 4],\n         [0, 1, 2, 2, 4, 3, 2, 3, 3, 3],\n         [0, 0, 4, 1, 4, 1, 0, 3, 1, 1],\n         [0, 0, 0, 2, 3, 1, 4, 1, 2, 1],\n         [0, 0, 0, 0, 1, 4, 2, 3, 0, 0]],\n\n        [[3, 6, 1, 1, 4, 3, 1, 2, 4, 6],\n         [0, 1, 0, 4, 4, 4, 3, 0, 0, 0],\n         [0, 0, 2, 4, 1, 1, 5, 4, 0, 4],\n         [0, 0, 0, 1, 2, 6, 1, 3, 1, 3],\n         [0, 0, 0, 0, 1, 5, 5, 1, 3, 6]]],\n\n\n       [[[1, 1, 1, 0, 0, 1, 1, 1, 1, 1],\n         [0, 1, 1, 1, 0, 0, 0, 1, 0, 0],\n         [0, 0, 1, 0, 0, 0, 0, 0, 0, 1],\n         [0, 0, 0, 1, 1, 0, 0, 0, 1, 1],\n         [0, 0, 0, 0, 1, 0, 1, 0, 1, 1]],\n\n        [[1, 2, 2, 0, 2, 1, 2, 0, 2, 2],\n         [0, 1, 1, 0, 2, 1, 1, 0, 1, 0],\n         [0, 0, 2, 1, 2, 2, 0, 2, 0, 1],\n         [0, 0, 0, 1, 1, 2, 2, 0, 2, 0],\n         [0, 0, 0, 0, 1, 0, 2, 2, 0, 2]]],\n\n\n       [[[2, 1, 1, 1, 1, 0, 1, 4, 1, 1],\n         [0, 4, 3, 3, 3, 2, 3, 1, 4, 3],\n         [0, 0, 3, 1, 1, 3, 3, 2, 0, 3],\n         [0, 0, 0, 1, 1, 3, 3, 4, 1, 1],\n         [0, 0, 0, 0, 4, 0, 4, 2, 3, 4]],\n\n        [[3, 1, 5, 1, 4, 5, 1, 5, 0, 1],\n         [0, 5, 2, 4, 3, 6, 1, 6, 2, 1],\n         [0, 0, 6, 4, 4, 6, 5, 0, 5, 1],\n         [0, 0, 0, 4, 6, 1, 2, 3, 5, 2],\n         [0, 0, 0, 0, 3, 3, 3, 6, 6, 0]]]], dtype=uint64)\n</code></pre>"},{"location":"#natural-order_2","title":"natural order","text":"<pre><code>&gt;&gt;&gt; print(qmctoolscl.gdn_gen_natural.__doc__)\nGeneralized digital net where the base can be different for each dimension e.g. for the Halton sequence\n\nArgs:\n    r (np.uint64): replications\n    n (np.uint64): points\n    d (np.uint64): dimension\n    r_b (np.uint64): number of replications of bases\n    mmax (np.uint64): columns in each generating matrix\n    tmax (np.uint64): rows of each generating matrix\n    n_start (np.uint64): starting index in sequence\n    bases (np.ndarray of np.uint64): bases for each dimension of size r_b*d\n    C (np.ndarray of np.uint64): generating matrices of size r*d*mmax*tmax\n    xdig (np.ndarray of np.uint64): generalized digital net sequence of digits of size r*n*d*tmax\n&gt;&gt;&gt; tmax = tmax_new\n&gt;&gt;&gt; C = C_lms\n&gt;&gt;&gt; n_start = np.uint64(2)\n&gt;&gt;&gt; n = np.uint64(6)\n&gt;&gt;&gt; xdig = np.empty((r,n,d,tmax),dtype=np.uint64)\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.gdn_gen_natural(r,n,d,r_b,mmax,tmax,n_start,bases,C,xdig,**kwargs)\n&gt;&gt;&gt; xdig\narray([[[[0, 1, 0, 0, 0, 0, 1, 0, 0, 1],\n         [1, 0, 2, 1, 1, 1, 1, 1, 0, 1]],\n\n        [[1, 0, 0, 0, 1, 1, 1, 1, 1, 0],\n         [0, 1, 0, 0, 1, 0, 2, 0, 2, 0]],\n\n        [[0, 0, 1, 0, 0, 0, 0, 0, 1, 0],\n         [2, 1, 1, 2, 0, 2, 1, 2, 2, 2]],\n\n        [[1, 1, 1, 0, 1, 1, 0, 1, 0, 1],\n         [1, 1, 2, 1, 2, 1, 0, 1, 2, 1]],\n\n        [[0, 1, 1, 0, 0, 0, 1, 0, 1, 1],\n         [0, 2, 0, 0, 2, 0, 1, 0, 1, 0]],\n\n        [[1, 0, 1, 0, 1, 1, 1, 1, 0, 0],\n         [2, 2, 1, 2, 1, 2, 0, 2, 1, 2]]],\n\n\n       [[[1, 2, 3, 3, 1, 1, 4, 1, 1, 3],\n         [6, 5, 2, 2, 1, 6, 2, 4, 1, 5]],\n\n        [[4, 3, 2, 2, 4, 4, 1, 4, 4, 2],\n         [2, 4, 3, 3, 5, 2, 3, 6, 5, 4]],\n\n        [[2, 4, 1, 1, 2, 2, 3, 2, 2, 1],\n         [5, 3, 4, 4, 2, 5, 4, 1, 2, 3]],\n\n        [[0, 1, 2, 2, 4, 3, 2, 3, 3, 3],\n         [1, 2, 5, 5, 6, 1, 5, 3, 6, 2]],\n\n        [[3, 2, 1, 1, 2, 1, 4, 1, 1, 2],\n         [4, 1, 6, 6, 3, 4, 6, 5, 3, 1]],\n\n        [[1, 3, 0, 0, 0, 4, 1, 4, 4, 1],\n         [0, 1, 0, 4, 4, 4, 3, 0, 0, 0]]],\n\n\n       [[[0, 1, 1, 1, 0, 0, 0, 1, 0, 0],\n         [2, 1, 1, 0, 1, 2, 1, 0, 1, 1]],\n\n        [[1, 0, 0, 1, 0, 1, 1, 0, 1, 1],\n         [0, 1, 1, 0, 2, 1, 1, 0, 1, 0]],\n\n        [[0, 0, 1, 0, 0, 0, 0, 0, 0, 1],\n         [1, 0, 0, 0, 1, 2, 0, 0, 0, 2]],\n\n        [[1, 1, 0, 0, 0, 1, 1, 1, 1, 0],\n         [2, 2, 2, 0, 0, 0, 2, 0, 2, 1]],\n\n        [[0, 1, 0, 1, 0, 0, 0, 1, 0, 1],\n         [0, 2, 2, 0, 1, 2, 2, 0, 2, 0]],\n\n        [[1, 0, 1, 1, 0, 1, 1, 0, 1, 0],\n         [1, 1, 1, 0, 0, 0, 1, 0, 1, 2]]],\n\n\n       [[[4, 2, 2, 2, 2, 0, 2, 3, 2, 2],\n         [6, 2, 3, 2, 1, 3, 2, 3, 0, 2]],\n\n        [[1, 3, 3, 3, 3, 0, 3, 2, 3, 3],\n         [2, 3, 1, 3, 5, 1, 3, 1, 0, 3]],\n\n        [[3, 4, 4, 4, 4, 0, 4, 1, 4, 4],\n         [5, 4, 6, 4, 2, 6, 4, 6, 0, 4]],\n\n        [[0, 4, 3, 3, 3, 2, 3, 1, 4, 3],\n         [1, 5, 4, 5, 6, 4, 5, 4, 0, 5]],\n\n        [[2, 0, 4, 4, 4, 2, 4, 0, 0, 4],\n         [4, 6, 2, 6, 3, 2, 6, 2, 0, 6]],\n\n        [[4, 1, 0, 0, 0, 2, 0, 4, 1, 0],\n         [0, 5, 2, 4, 3, 6, 1, 6, 2, 1]]]], dtype=uint64)\n</code></pre>"},{"location":"#digital-shift_1","title":"digital shift","text":"<pre><code>&gt;&gt;&gt; print(qmctoolscl.gdn_digital_shift.__doc__)\nDigital shift a generalized digital net\n\nArgs:\n    r (np.uint64): replications\n    n (np.uint64): points\n    d (np.uint64): dimension\n    r_x (np.uint64): replications of xdig\n    r_b (np.uint64): replications of bases\n    tmax (np.uint64): rows of each generating matrix\n    tmax_new (np.uint64): rows of each new generating matrix\n    bases (np.ndarray of np.uint64): bases for each dimension of size r_b*d\n    shifts (np.ndarray of np.uint64): digital shifts of size r*d*tmax_new\n    xdig (np.ndarray of np.uint64): binary digital net points of size r_x*n*d*tmax\n    xdig_new (np.ndarray of np.uint64): float digital net points of size r*n*d*tmax_new\n&gt;&gt;&gt; r_x = r\n&gt;&gt;&gt; tmax_new = np.uint64(12)\n&gt;&gt;&gt; print(qmctoolscl.gdn_get_digital_shifts.__doc__)\nReturn digital shifts for gdn\n\nArgs: \n    rng (np.random._generator.Generator): random number generator\n    r (np.uint64): replications \n    d (np.uint64): dimension \n    tmax_new (np.uint64): number of bits in each shift \n    r_b (np.uint64): replications of bases \n    bases (np.ndarray of np.uint64): bases of size r_b*d\n&gt;&gt;&gt; shifts = qmctoolscl.gdn_get_digital_shifts(rng,r,d,tmax_new,r_b,bases)\n&gt;&gt;&gt; shifts\narray([[[0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1],\n        [1, 2, 0, 2, 2, 0, 0, 0, 1, 0, 0, 1]],\n\n       [[4, 0, 0, 1, 2, 0, 0, 1, 0, 3, 2, 1],\n        [1, 3, 6, 5, 0, 2, 5, 2, 1, 6, 6, 6]],\n\n       [[1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0],\n        [1, 0, 1, 0, 2, 0, 2, 2, 2, 0, 1, 1]],\n\n       [[0, 4, 1, 0, 2, 2, 2, 2, 1, 1, 1, 1],\n        [5, 5, 1, 3, 0, 4, 5, 4, 3, 0, 3, 2]]], dtype=uint64)\n&gt;&gt;&gt; xdig_new = np.empty((r,n,d,tmax_new),dtype=np.uint64)\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.gdn_digital_shift(r,n,d,r_x,r_b,tmax,tmax_new,bases,shifts,xdig,xdig_new,**kwargs)\n&gt;&gt;&gt; xdig_new\narray([[[[0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1],\n         [2, 2, 2, 0, 0, 1, 1, 1, 1, 1, 0, 1]],\n\n        [[1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1],\n         [1, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 1]],\n\n        [[0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1],\n         [0, 0, 1, 1, 2, 2, 1, 2, 0, 2, 0, 1]],\n\n        [[1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1],\n         [2, 0, 2, 0, 1, 1, 0, 1, 0, 1, 0, 1]],\n\n        [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],\n         [1, 1, 0, 2, 1, 0, 1, 0, 2, 0, 0, 1]],\n\n        [[1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1],\n         [0, 1, 1, 1, 0, 2, 0, 2, 2, 2, 0, 1]]],\n\n\n       [[[0, 2, 3, 4, 3, 1, 4, 2, 1, 1, 2, 1],\n         [0, 1, 1, 0, 1, 1, 0, 6, 2, 4, 6, 6]],\n\n        [[3, 3, 2, 3, 1, 4, 1, 0, 4, 0, 2, 1],\n         [3, 0, 2, 1, 5, 4, 1, 1, 6, 3, 6, 6]],\n\n        [[1, 4, 1, 2, 4, 2, 3, 3, 2, 4, 2, 1],\n         [6, 6, 3, 2, 2, 0, 2, 3, 3, 2, 6, 6]],\n\n        [[4, 1, 2, 3, 1, 3, 2, 4, 3, 1, 2, 1],\n         [2, 5, 4, 3, 6, 3, 3, 5, 0, 1, 6, 6]],\n\n        [[2, 2, 1, 2, 4, 1, 4, 2, 1, 0, 2, 1],\n         [5, 4, 5, 4, 3, 6, 4, 0, 4, 0, 6, 6]],\n\n        [[0, 3, 0, 1, 2, 4, 1, 0, 4, 4, 2, 1],\n         [1, 4, 6, 2, 4, 6, 1, 2, 1, 6, 6, 6]]],\n\n\n       [[[1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0],\n         [0, 1, 2, 0, 0, 2, 0, 2, 0, 1, 1, 1]],\n\n        [[0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0],\n         [1, 1, 2, 0, 1, 1, 0, 2, 0, 0, 1, 1]],\n\n        [[1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0],\n         [2, 0, 1, 0, 0, 2, 2, 2, 2, 2, 1, 1]],\n\n        [[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0],\n         [0, 2, 0, 0, 2, 0, 1, 2, 1, 1, 1, 1]],\n\n        [[1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0],\n         [1, 2, 0, 0, 0, 2, 1, 2, 1, 0, 1, 1]],\n\n        [[0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0],\n         [2, 1, 2, 0, 2, 0, 0, 2, 0, 2, 1, 1]]],\n\n\n       [[[4, 1, 3, 2, 4, 2, 4, 0, 3, 3, 1, 1],\n         [4, 0, 4, 5, 1, 0, 0, 0, 3, 2, 3, 2]],\n\n        [[1, 2, 4, 3, 0, 2, 0, 4, 4, 4, 1, 1],\n         [0, 1, 2, 6, 5, 5, 1, 5, 3, 3, 3, 2]],\n\n        [[3, 3, 0, 4, 1, 2, 1, 3, 0, 0, 1, 1],\n         [3, 2, 0, 0, 2, 3, 2, 3, 3, 4, 3, 2]],\n\n        [[0, 3, 4, 3, 0, 4, 0, 3, 0, 4, 1, 1],\n         [6, 3, 5, 1, 6, 1, 3, 1, 3, 5, 3, 2]],\n\n        [[2, 4, 0, 4, 1, 4, 1, 2, 1, 0, 1, 1],\n         [2, 4, 3, 2, 3, 6, 4, 6, 3, 6, 3, 2]],\n\n        [[4, 0, 1, 0, 2, 4, 2, 1, 2, 1, 1, 1],\n         [5, 3, 3, 0, 3, 3, 6, 3, 5, 1, 3, 2]]]], dtype=uint64)\n</code></pre>"},{"location":"#digital-permutation","title":"digital permutation","text":"<pre><code>&gt;&gt;&gt; print(qmctoolscl.gdn_digital_permutation.__doc__)\nPermutation of digits for a generalized digital net\n\nArgs:\n    r (np.uint64): replications\n    n (np.uint64): points\n    d (np.uint64): dimension\n    r_x (np.uint64): replications of xdig\n    r_b (np.uint64): replications of bases\n    tmax (np.uint64): rows of each generating matrix\n    tmax_new (np.uint64): rows of each new generating matrix\n    bmax (np.uint64): common permutation size, typically the maximum basis\n    perms (np.ndarray of np.uint64): permutations of size r*d*tmax_new*bmax\n    xdig (np.ndarray of np.uint64): binary digital net points of size r_x*n*d*tmax\n    xdig_new (np.ndarray of np.uint64): float digital net points of size r*n*d*tmax_new\n&gt;&gt;&gt; print(qmctoolscl.gdn_get_permutations.__doc__)\nReturn permutations for gdn\n\nArgs: \n    rng (np.random._generator.Generator): random number generator\n    r (np.uint64): replications \n    d (np.uint64): dimension \n    tmax_new (np.uint64): number of bits in each shift \n    r_b (np.uint64): replications of bases \n    bases (np.ndarray of np.uint64): bases of size r_b*d\n&gt;&gt;&gt; perms = qmctoolscl.gdn_get_permutations(rng,r,d,tmax_new,r_b,bases)\n&gt;&gt;&gt; perms\narray([[[[1, 0, 0, 0, 0, 0, 0],\n         [0, 1, 0, 0, 0, 0, 0],\n         [1, 0, 0, 0, 0, 0, 0],\n         [1, 0, 0, 0, 0, 0, 0],\n         [1, 0, 0, 0, 0, 0, 0],\n         [0, 1, 0, 0, 0, 0, 0],\n         [1, 0, 0, 0, 0, 0, 0],\n         [1, 0, 0, 0, 0, 0, 0],\n         [0, 1, 0, 0, 0, 0, 0],\n         [1, 0, 0, 0, 0, 0, 0],\n         [0, 1, 0, 0, 0, 0, 0],\n         [1, 0, 0, 0, 0, 0, 0]],\n\n        [[0, 1, 2, 0, 0, 0, 0],\n         [1, 0, 2, 0, 0, 0, 0],\n         [0, 1, 2, 0, 0, 0, 0],\n         [2, 1, 0, 0, 0, 0, 0],\n         [0, 2, 1, 0, 0, 0, 0],\n         [2, 0, 1, 0, 0, 0, 0],\n         [2, 0, 1, 0, 0, 0, 0],\n         [1, 0, 2, 0, 0, 0, 0],\n         [1, 2, 0, 0, 0, 0, 0],\n         [2, 1, 0, 0, 0, 0, 0],\n         [2, 0, 1, 0, 0, 0, 0],\n         [2, 1, 0, 0, 0, 0, 0]]],\n\n\n       [[[3, 4, 0, 2, 1, 0, 0],\n         [3, 0, 1, 4, 2, 0, 0],\n         [1, 3, 2, 0, 4, 0, 0],\n         [1, 0, 3, 4, 2, 0, 0],\n         [3, 2, 1, 4, 0, 0, 0],\n         [1, 0, 3, 4, 2, 0, 0],\n         [1, 3, 0, 4, 2, 0, 0],\n         [0, 4, 1, 2, 3, 0, 0],\n         [2, 4, 3, 1, 0, 0, 0],\n         [2, 1, 4, 0, 3, 0, 0],\n         [2, 0, 4, 1, 3, 0, 0],\n         [1, 4, 2, 3, 0, 0, 0]],\n\n        [[5, 0, 1, 3, 2, 6, 4],\n         [4, 2, 3, 1, 6, 0, 5],\n         [6, 2, 0, 5, 1, 4, 3],\n         [2, 0, 3, 5, 6, 4, 1],\n         [0, 6, 2, 1, 4, 3, 5],\n         [3, 2, 5, 4, 6, 0, 1],\n         [1, 4, 3, 6, 5, 0, 2],\n         [5, 6, 4, 2, 3, 0, 1],\n         [3, 0, 1, 4, 2, 5, 6],\n         [3, 2, 6, 1, 0, 4, 5],\n         [1, 4, 3, 2, 5, 0, 6],\n         [6, 0, 4, 1, 5, 3, 2]]],\n\n\n       [[[1, 0, 0, 0, 0, 0, 0],\n         [0, 1, 0, 0, 0, 0, 0],\n         [0, 1, 0, 0, 0, 0, 0],\n         [1, 0, 0, 0, 0, 0, 0],\n         [0, 1, 0, 0, 0, 0, 0],\n         [0, 1, 0, 0, 0, 0, 0],\n         [1, 0, 0, 0, 0, 0, 0],\n         [1, 0, 0, 0, 0, 0, 0],\n         [1, 0, 0, 0, 0, 0, 0],\n         [0, 1, 0, 0, 0, 0, 0],\n         [1, 0, 0, 0, 0, 0, 0],\n         [1, 0, 0, 0, 0, 0, 0]],\n\n        [[1, 2, 0, 0, 0, 0, 0],\n         [1, 2, 0, 0, 0, 0, 0],\n         [2, 0, 1, 0, 0, 0, 0],\n         [1, 0, 2, 0, 0, 0, 0],\n         [2, 0, 1, 0, 0, 0, 0],\n         [2, 0, 1, 0, 0, 0, 0],\n         [0, 1, 2, 0, 0, 0, 0],\n         [0, 2, 1, 0, 0, 0, 0],\n         [2, 1, 0, 0, 0, 0, 0],\n         [1, 2, 0, 0, 0, 0, 0],\n         [0, 1, 2, 0, 0, 0, 0],\n         [0, 1, 2, 0, 0, 0, 0]]],\n\n\n       [[[1, 3, 0, 2, 4, 0, 0],\n         [4, 3, 2, 1, 0, 0, 0],\n         [0, 4, 1, 3, 2, 0, 0],\n         [1, 4, 2, 3, 0, 0, 0],\n         [1, 2, 0, 4, 3, 0, 0],\n         [1, 0, 2, 4, 3, 0, 0],\n         [3, 2, 0, 4, 1, 0, 0],\n         [2, 4, 0, 1, 3, 0, 0],\n         [2, 3, 1, 4, 0, 0, 0],\n         [4, 0, 2, 1, 3, 0, 0],\n         [0, 1, 3, 4, 2, 0, 0],\n         [2, 0, 1, 3, 4, 0, 0]],\n\n        [[1, 0, 4, 5, 6, 2, 3],\n         [4, 5, 0, 3, 1, 6, 2],\n         [4, 2, 1, 5, 3, 0, 6],\n         [3, 1, 4, 5, 6, 0, 2],\n         [0, 1, 3, 6, 2, 4, 5],\n         [4, 0, 2, 6, 1, 5, 3],\n         [0, 6, 4, 2, 1, 3, 5],\n         [5, 1, 3, 4, 0, 6, 2],\n         [4, 6, 0, 1, 3, 5, 2],\n         [3, 2, 6, 5, 0, 4, 1],\n         [3, 4, 2, 6, 1, 5, 0],\n         [2, 6, 1, 3, 0, 4, 5]]]], dtype=uint64)\n&gt;&gt;&gt; bmax = bases.max().astype(np.uint64)\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.gdn_digital_permutation(r,n,d,r_x,r_b,tmax,tmax_new,bmax,perms,xdig,xdig_new,**kwargs)\n&gt;&gt;&gt; xdig_new\narray([[[[1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1],\n         [1, 1, 2, 1, 2, 0, 0, 0, 1, 1, 2, 2]],\n\n        [[0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1],\n         [0, 0, 0, 2, 2, 2, 1, 1, 0, 2, 2, 2]],\n\n        [[1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1],\n         [2, 0, 1, 0, 0, 1, 0, 2, 0, 0, 2, 2]],\n\n        [[0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1],\n         [1, 0, 2, 1, 1, 0, 2, 0, 0, 1, 2, 2]],\n\n        [[1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1],\n         [0, 2, 0, 2, 1, 2, 0, 1, 2, 2, 2, 2]],\n\n        [[0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1],\n         [2, 2, 1, 0, 2, 1, 2, 2, 2, 0, 2, 2]]],\n\n\n       [[[4, 1, 0, 4, 2, 0, 2, 4, 4, 0, 2, 1],\n         [4, 0, 0, 3, 6, 1, 3, 3, 0, 4, 1, 6]],\n\n        [[1, 4, 2, 3, 0, 2, 3, 3, 0, 4, 2, 1],\n         [1, 6, 5, 5, 3, 5, 6, 1, 5, 0, 1, 6]],\n\n        [[0, 2, 3, 0, 1, 3, 4, 1, 3, 1, 2, 1],\n         [6, 1, 1, 6, 2, 0, 5, 6, 1, 1, 1, 6]],\n\n        [[3, 0, 2, 3, 0, 4, 0, 2, 1, 0, 2, 1],\n         [0, 3, 4, 4, 5, 2, 0, 2, 6, 6, 1, 6]],\n\n        [[2, 1, 3, 0, 1, 0, 2, 4, 4, 4, 2, 1],\n         [2, 2, 3, 1, 1, 6, 2, 0, 4, 2, 1, 6]],\n\n        [[4, 4, 1, 1, 3, 2, 3, 3, 0, 1, 2, 1],\n         [5, 2, 6, 6, 4, 6, 6, 5, 3, 3, 1, 6]]],\n\n\n       [[[1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1],\n         [0, 2, 0, 1, 0, 1, 1, 0, 1, 2, 0, 0]],\n\n        [[0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1],\n         [1, 2, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0]],\n\n        [[1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1],\n         [2, 1, 2, 1, 0, 1, 0, 0, 2, 0, 0, 0]],\n\n        [[0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1],\n         [0, 0, 1, 1, 2, 2, 2, 0, 0, 2, 0, 0]],\n\n        [[1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1],\n         [1, 0, 1, 1, 0, 1, 2, 0, 0, 1, 0, 0]],\n\n        [[0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1],\n         [2, 2, 0, 1, 2, 2, 1, 0, 1, 0, 0, 0]]],\n\n\n       [[[4, 2, 1, 2, 0, 1, 0, 1, 1, 2, 0, 2],\n         [3, 0, 5, 4, 1, 6, 4, 4, 4, 6, 3, 2]],\n\n        [[3, 1, 3, 3, 4, 1, 4, 0, 4, 1, 0, 2],\n         [4, 3, 2, 5, 4, 0, 2, 1, 4, 5, 3, 2]],\n\n        [[2, 0, 2, 0, 3, 1, 1, 4, 0, 3, 0, 2],\n         [2, 1, 6, 6, 3, 3, 1, 2, 4, 0, 3, 2]],\n\n        [[1, 0, 3, 3, 4, 2, 4, 4, 0, 1, 0, 2],\n         [0, 6, 3, 0, 5, 1, 3, 0, 4, 4, 3, 2]],\n\n        [[0, 4, 2, 0, 3, 2, 1, 2, 2, 3, 0, 2],\n         [6, 2, 1, 2, 6, 2, 5, 3, 4, 1, 3, 2]],\n\n        [[4, 3, 0, 1, 1, 2, 3, 3, 3, 4, 0, 2],\n         [1, 6, 1, 6, 6, 3, 6, 2, 0, 2, 3, 2]]]], dtype=uint64)\n</code></pre>"},{"location":"#convert-digits-to-doubles_1","title":"convert digits to doubles","text":"<pre><code>&gt;&gt;&gt; print(qmctoolscl.gdn_integer_to_float.__doc__)\nConvert digits of generalized digital net to floats\n\nArgs:\n    r (np.uint64): replications\n    n (np.uint64): points\n    d (np.uint64): dimension\n    r_b (np.uint64): replications of bases \n    tmax (np.uint64): rows of each generating matrix\n    bases (np.ndarray of np.uint64): bases for each dimension of size r_b*d\n    xdig (np.ndarray of np.uint64): binary digital net points of size r*n*d*tmax\n    x (np.ndarray of np.double): float digital net points of size r*n*d\n&gt;&gt;&gt; x = np.empty((r,n,d),dtype=np.float64)\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.gdn_integer_to_float(r,n,d,r_b,tmax_new,bases,xdig_new,x,**kwargs)\n&gt;&gt;&gt; x\narray([[[0.97290039, 0.53917744],\n        [0.20629883, 0.03632388],\n        [0.60864258, 0.70539533],\n        [0.33618164, 0.4248148 ],\n        [0.84985352, 0.25407524],\n        [0.0793457 , 0.93686411]],\n\n       [[0.84707793, 0.57304772],\n        [0.38097453, 0.28219443],\n        [0.10456744, 0.88309157],\n        [0.62106168, 0.07486728],\n        [0.46435834, 0.33580649],\n        [0.97073423, 0.77539095]],\n\n       [[0.88549805, 0.23648157],\n        [0.02124023, 0.57254145],\n        [0.70288086, 0.86567088],\n        [0.32885742, 0.06130502],\n        [0.76147461, 0.38501922],\n        [0.14526367, 0.91271656]],\n\n       [[0.89126728, 0.44493083],\n        [0.67019736, 0.64080715],\n        [0.41704736, 0.32631978],\n        [0.23026955, 0.13150509],\n        [0.17710726, 0.90208831],\n        [0.92209603, 0.27111067]]])\n</code></pre>"},{"location":"#nested-uniform-scramble","title":"nested uniform scramble","text":"<pre><code>&gt;&gt;&gt; r = np.uint64(1)\n&gt;&gt;&gt; n_start = np.uint64(0) \n&gt;&gt;&gt; n = np.uint64(9)\n&gt;&gt;&gt; bases = np.array([[2,3,5]],dtype=np.uint64)\n&gt;&gt;&gt; r_b = np.uint64(bases.shape[0])\n&gt;&gt;&gt; d = np.uint64(bases.shape[1])\n&gt;&gt;&gt; mmax = np.uint64(3)\n&gt;&gt;&gt; tmax = mmax\n&gt;&gt;&gt; C = np.tile(np.eye(mmax,dtype=np.uint64)[None,None,:,:],(int(r),int(d),1,1))\n&gt;&gt;&gt; xdig = np.empty((r,n,d,tmax),dtype=np.uint64)\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.gdn_gen_natural(r,n,d,r_b,mmax,tmax,n_start,bases,C,xdig)\n&gt;&gt;&gt; r_x = r \n&gt;&gt;&gt; r = np.uint64(2) \n&gt;&gt;&gt; tmax_new = np.uint64(8)\n&gt;&gt;&gt; base_seed_seq = np.random.SeedSequence(7)\n&gt;&gt;&gt; seeds = base_seed_seq.spawn(r*d)\n&gt;&gt;&gt; rngs = np.array([np.random.Generator(np.random.SFC64(seed)) for seed in seeds]).reshape(r,d)\n&gt;&gt;&gt; root_nodes = np.array([qmctoolscl.NUSNode_gdn() for i in range(r*d)]).reshape(r,d)\n&gt;&gt;&gt; xrdig = np.zeros((r,n,d,tmax_new),dtype=np.uint64)\n&gt;&gt;&gt; print(qmctoolscl.gdn_nested_uniform_scramble.__doc__)\nNested uniform scramble of general digital nets\n\nArgs: \n    r (np.uint64): replications \n    n (np.uint64): points\n    d (np.uint64): dimensions\n    r_x (np.uint64): replications of xb\n    r_b (np.uint64): replications of bases\n    tmax (np.uint64): maximum number digits in each point representation\n    tmax_new (np.uint64): maximum number digits in each point representation after scrambling\n    rngs (np.ndarray of numpy.random._generator.Generator): random number generators of size r*d\n    root_nodes (np.ndarray of NUSNode_gdn): root nodes of size r*d\n    bases (np.ndarray of np.uint64): array of bases of size r*d\n    xdig (np.ndarray of np.uint64): array of unrandomized points of size r*n*d*tmax\n    xrdig (np.ndarray of np.uint64): array to store scrambled points of size r*n*d*tmax_new\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.gdn_nested_uniform_scramble(r,n,d,r_x,r_b,tmax,tmax_new,rngs,root_nodes,bases,xdig,xrdig)\n&gt;&gt;&gt; xrdig \narray([[[[0, 0, 1, 0, 0, 1, 0, 0],\n         [2, 2, 2, 2, 1, 0, 2, 1],\n         [3, 4, 2, 0, 3, 4, 1, 0]],\n\n        [[1, 0, 1, 0, 1, 0, 1, 1],\n         [1, 0, 1, 0, 1, 0, 1, 2],\n         [1, 0, 3, 3, 3, 0, 1, 2]],\n\n        [[0, 1, 1, 1, 1, 0, 0, 0],\n         [0, 2, 2, 0, 0, 2, 0, 2],\n         [4, 1, 2, 1, 4, 3, 0, 0]],\n\n        [[1, 1, 0, 0, 0, 1, 0, 1],\n         [2, 1, 1, 1, 0, 2, 2, 2],\n         [2, 3, 2, 4, 2, 2, 2, 0]],\n\n        [[0, 0, 0, 0, 0, 1, 0, 0],\n         [1, 2, 2, 0, 1, 1, 2, 0],\n         [0, 1, 0, 4, 3, 1, 3, 0]],\n\n        [[1, 0, 0, 0, 1, 1, 1, 1],\n         [0, 0, 2, 0, 0, 1, 0, 2],\n         [3, 2, 1, 4, 2, 1, 4, 1]],\n\n        [[0, 1, 0, 0, 0, 0, 0, 0],\n         [2, 0, 1, 1, 1, 0, 1, 2],\n         [1, 1, 4, 4, 4, 0, 1, 1]],\n\n        [[1, 1, 1, 1, 1, 0, 1, 1],\n         [1, 1, 1, 2, 0, 0, 0, 0],\n         [4, 4, 1, 4, 1, 2, 3, 0]],\n\n        [[1, 0, 1, 0, 0, 0, 0, 0],\n         [0, 1, 2, 0, 2, 1, 0, 1],\n         [2, 1, 0, 0, 1, 2, 3, 0]]],\n\n\n       [[[0, 0, 0, 0, 1, 1, 0, 0],\n         [0, 1, 1, 1, 0, 0, 2, 1],\n         [2, 4, 0, 0, 1, 1, 0, 0]],\n\n        [[1, 0, 1, 0, 1, 0, 0, 1],\n         [1, 0, 1, 2, 0, 0, 0, 1],\n         [1, 1, 1, 1, 3, 0, 1, 0]],\n\n        [[0, 1, 0, 1, 0, 1, 0, 1],\n         [2, 0, 1, 0, 0, 2, 1, 0],\n         [0, 0, 2, 2, 0, 0, 4, 0]],\n\n        [[1, 1, 0, 0, 1, 1, 1, 0],\n         [0, 2, 1, 1, 2, 1, 2, 2],\n         [4, 1, 4, 3, 4, 0, 1, 3]],\n\n        [[0, 0, 1, 1, 0, 1, 0, 0],\n         [1, 2, 2, 2, 1, 1, 0, 1],\n         [3, 1, 0, 4, 2, 0, 1, 2]],\n\n        [[1, 0, 0, 1, 1, 0, 0, 0],\n         [2, 1, 0, 2, 0, 1, 1, 1],\n         [2, 3, 2, 0, 4, 3, 2, 1]],\n\n        [[0, 1, 1, 0, 1, 0, 1, 1],\n         [0, 0, 0, 1, 2, 1, 1, 0],\n         [1, 3, 3, 4, 4, 4, 0, 4]],\n\n        [[1, 1, 1, 1, 0, 1, 0, 0],\n         [1, 1, 1, 1, 0, 1, 0, 0],\n         [0, 2, 1, 4, 3, 3, 2, 0]],\n\n        [[1, 0, 1, 0, 0, 0, 0, 0],\n         [2, 2, 2, 2, 2, 2, 2, 1],\n         [4, 3, 0, 0, 4, 2, 0, 4]]]], dtype=uint64)\n&gt;&gt;&gt; xr = np.empty((r,n,d),dtype=np.float64) \n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.gdn_integer_to_float(r,n,d,r_b,tmax_new,bases,xrdig,xr)\n&gt;&gt;&gt; xr\narray([[[0.140625  , 0.99283646, 0.7772288 ],\n        [0.66796875, 0.37524768, 0.22977792],\n        [0.46875   , 0.29934461, 0.859072  ],\n        [0.76953125, 0.8311233 , 0.5431936 ],\n        [0.015625  , 0.63603109, 0.0474624 ],\n        [0.55859375, 0.07575065, 0.69515776],\n        [0.25      , 0.72092669, 0.27969536],\n        [0.98046875, 0.50617284, 0.9748864 ],\n        [0.625     , 0.1949398 , 0.4404864 ]],\n\n       [[0.046875  , 0.16156074, 0.560384  ],\n        [0.66015625, 0.39521414, 0.2505728 ],\n        [0.33203125, 0.70690444, 0.0192512 ],\n        [0.8046875 , 0.28242646, 0.87810048],\n        [0.203125  , 0.65996037, 0.64705792],\n        [0.59375   , 0.80445054, 0.53750016],\n        [0.41796875, 0.02240512, 0.35194624],\n        [0.953125  , 0.4951989 , 0.0955776 ],\n        [0.625     , 0.99969517, 0.92141824]]])\n</code></pre>"},{"location":"#digital-interlacing_1","title":"digital interlacing","text":"<pre><code>&gt;&gt;&gt; print(qmctoolscl.gdn_interlace.__doc__)\nInterlace generating matrices or transpose of point sets to attain higher order digital nets\n\nArgs:\n    r (np.uint64): replications\n    d_alpha (np.uint64): dimension of resulting generating matrices \n    mmax (np.uint64): columns of generating matrices\n    d (np.uint64): dimension of original generating matrices\n    tmax (np.uint64): rows of original generating matrices\n    tmax_alpha (np.uint64): rows of interlaced generating matrices\n    alpha (np.uint64): interlacing factor\n    C (np.ndarray of np.uint64): original generating matrices of size r*d*mmax*tmax\n    C_alpha (np.ndarray of np.uint64): resulting interlaced generating matrices of size r*d_alpha*mmax*tmax_alpha\n&gt;&gt;&gt; r = np.uint64(2)\n&gt;&gt;&gt; d = np.uint64(6)\n&gt;&gt;&gt; alpha = np.uint64(3)\n&gt;&gt;&gt; d_alpha = np.uint64(d//alpha)\n&gt;&gt;&gt; mmax = np.uint64(3)\n&gt;&gt;&gt; tmax = np.uint64(4)\n&gt;&gt;&gt; tmax_alpha = np.uint64(alpha*tmax)\n&gt;&gt;&gt; C = rng.integers(0,5,(r,d,mmax,tmax),dtype=np.uint64)\n&gt;&gt;&gt; C\narray([[[[0, 4, 4, 0],\n         [0, 2, 4, 0],\n         [1, 2, 4, 4]],\n\n        [[2, 4, 3, 4],\n         [4, 0, 1, 2],\n         [0, 2, 0, 0]],\n\n        [[1, 1, 3, 1],\n         [3, 3, 1, 1],\n         [1, 3, 2, 0]],\n\n        [[1, 1, 4, 2],\n         [4, 2, 4, 4],\n         [1, 0, 3, 1]],\n\n        [[1, 4, 3, 0],\n         [2, 4, 4, 4],\n         [1, 4, 2, 4]],\n\n        [[0, 2, 3, 1],\n         [3, 1, 1, 0],\n         [3, 0, 1, 0]]],\n\n\n       [[[4, 4, 3, 2],\n         [3, 3, 3, 0],\n         [4, 3, 3, 3]],\n\n        [[2, 3, 2, 0],\n         [0, 4, 0, 2],\n         [2, 2, 1, 0]],\n\n        [[3, 0, 1, 4],\n         [4, 1, 3, 3],\n         [0, 3, 1, 0]],\n\n        [[2, 0, 3, 1],\n         [4, 1, 3, 1],\n         [3, 1, 0, 4]],\n\n        [[2, 0, 2, 0],\n         [4, 0, 1, 3],\n         [0, 1, 1, 1]],\n\n        [[4, 4, 0, 1],\n         [2, 3, 0, 3],\n         [0, 1, 4, 0]]]], dtype=uint64)\n&gt;&gt;&gt; C_alpha = np.empty((r,d_alpha,mmax,tmax_alpha),dtype=np.uint64)\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.gdn_interlace(r,d_alpha,mmax,d,tmax,tmax_alpha,alpha,C,C_alpha)\n&gt;&gt;&gt; C_alpha\narray([[[[0, 2, 1, 4, 4, 1, 4, 3, 3, 0, 4, 1],\n         [0, 4, 3, 2, 0, 3, 4, 1, 1, 0, 2, 1],\n         [1, 0, 1, 2, 2, 3, 4, 0, 2, 4, 0, 0]],\n\n        [[1, 1, 0, 1, 4, 2, 4, 3, 3, 2, 0, 1],\n         [4, 2, 3, 2, 4, 1, 4, 4, 1, 4, 4, 0],\n         [1, 1, 3, 0, 4, 0, 3, 2, 1, 1, 4, 0]]],\n\n\n       [[[4, 2, 3, 4, 3, 0, 3, 2, 1, 2, 0, 4],\n         [3, 0, 4, 3, 4, 1, 3, 0, 3, 0, 2, 3],\n         [4, 2, 0, 3, 2, 3, 3, 1, 1, 3, 0, 0]],\n\n        [[2, 2, 4, 0, 0, 4, 3, 2, 0, 1, 0, 1],\n         [4, 4, 2, 1, 0, 3, 3, 1, 0, 1, 3, 3],\n         [3, 0, 0, 1, 1, 1, 0, 1, 4, 4, 1, 0]]]], dtype=uint64)\n</code></pre>"},{"location":"#undo-digital-interlacing_1","title":"undo digital interlacing","text":"<pre><code>&gt;&gt;&gt; print(qmctoolscl.gdn_undo_interlace.__doc__)\nUndo interlacing of generating matrices\n\nArgs:\n    r (np.uint64): replications\n    d (np.uint64): dimension of resulting generating matrices \n    mmax (np.uint64): columns in generating matrices\n    d_alpha (np.uint64): dimension of interlaced generating matrices\n    tmax (np.uint64): rows of original generating matrices\n    tmax_alpha (np.uint64): rows of interlaced generating matrices\n    alpha (np.uint64): interlacing factor\n    C_alpha (np.ndarray of np.uint64): interlaced generating matrices of size r*d_alpha*mmax*tmax_alpha\n    C (np.ndarray of np.uint64): original generating matrices of size r*d*mmax*tmax\n&gt;&gt;&gt; C_cp = np.empty((r,d,mmax,tmax),dtype=np.uint64)\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.gdn_undo_interlace(r,d,mmax,d_alpha,tmax,tmax_alpha,alpha,C_alpha,C_cp) \n&gt;&gt;&gt; print((C==C_cp).all())\nTrue\n</code></pre>"},{"location":"#natural-order-with-the-same-base","title":"natural order with the same base","text":"<pre><code>&gt;&gt;&gt; print(qmctoolscl.gdn_gen_natural_same_base.__doc__)\nGeneralized digital net with the same base for each dimension e.g. a digital net in base greater than 2\n\nArgs:\n    r (np.uint64): replications\n    n (np.uint64): points\n    d (np.uint64): dimension\n    mmax (np.uint64): columns in each generating matrix\n    tmax (np.uint64): rows of each generating matrix\n    n_start (np.uint64): starting index in sequence\n    b (np.uint64): common base\n    C (np.ndarray of np.uint64): generating matrices of size r*d*mmax*tmax\n    xdig (np.ndarray of np.uint64): generalized digital net sequence of digits of size r*n*d*tmax\n&gt;&gt;&gt; n_start = np.uint64(0)\n&gt;&gt;&gt; n = np.uint64(9)\n&gt;&gt;&gt; b = np.uint64(3) \n&gt;&gt;&gt; C = np.array([[\n...     [\n...         [1,1,0,0],\n...         [1,1,1,1],\n...     ],\n...     [\n...         [2,1,0,0],\n...         [2,1,2,1],\n...     ]\n...     ]],\n...     dtype=np.uint64)\n&gt;&gt;&gt; r = np.uint64(C.shape[0])\n&gt;&gt;&gt; d = np.uint64(C.shape[1])\n&gt;&gt;&gt; mmax = np.uint64(C.shape[2])\n&gt;&gt;&gt; tmax = np.uint64(C.shape[3])\n&gt;&gt;&gt; xdig = np.empty((r,n,d,tmax),dtype=np.uint64) \n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.gdn_gen_natural_same_base(r,n,d,mmax,tmax,n_start,b,C,xdig)\n&gt;&gt;&gt; xdig\narray([[[[0, 0, 0, 0],\n         [0, 0, 0, 0]],\n\n        [[1, 1, 0, 0],\n         [2, 1, 0, 0]],\n\n        [[2, 2, 0, 0],\n         [1, 2, 0, 0]],\n\n        [[1, 1, 1, 1],\n         [2, 1, 2, 1]],\n\n        [[2, 2, 1, 1],\n         [1, 2, 2, 1]],\n\n        [[0, 0, 1, 1],\n         [0, 0, 2, 1]],\n\n        [[2, 2, 2, 2],\n         [1, 2, 1, 2]],\n\n        [[0, 0, 2, 2],\n         [0, 0, 1, 2]],\n\n        [[1, 1, 2, 2],\n         [2, 1, 1, 2]]]], dtype=uint64)\n</code></pre>"},{"location":"#fast-transforms","title":"Fast Transforms","text":"<p>Fast transforms require the use of a single work group for the final dimension i.e. it is required that <code>global_size[2]==local_size[2]</code></p> <pre><code>&gt;&gt;&gt; if kwargs[\"backend\"]==\"CL\":\n...     kwargs_ft = kwargs.copy()\n...     kwargs_ft[\"global_size\"] = (2,2,2)\n...     kwargs_ft[\"local_size\"] = (1,1,2)\n... else: ## kwargs[\"backend\"]==\"C\"\n...     kwargs_ft = kwargs \n</code></pre>"},{"location":"#inverse-fast-fourier-transform","title":"(inverse) fast Fourier transform","text":"<pre><code>&gt;&gt;&gt; print(qmctoolscl.fft_bro_1d_radix2.__doc__)\nFast Fourier Transform for inputs in bit reversed order.\nFFT is done in place along the last dimension where the size is required to be a power of 2.\nFollows a decimation-in-time procedure described in https://www.cmlab.csie.ntu.edu.tw/cml/dsp/training/coding/transform/fft.html.\n\nArgs:\n    d1 (np.uint64): first dimension\n    d2 (np.uint64): second dimension\n    n_half (np.uint64): half of the last dimension of size n = 2n_half along which FFT is performed\n    twiddler (np.ndarray of np.double): size n vector used to store real twiddle factors\n    twiddlei (np.ndarray of np.double): size n vector used to store imaginary twiddle factors \n    xr (np.ndarray of np.double): real array of size d1*d2*n on which to perform FFT in place\n    xi (np.ndarray of np.double): imaginary array of size d1*d2*n on which to perform FFT in place\n&gt;&gt;&gt; print(qmctoolscl.ifft_bro_1d_radix2.__doc__)\nInverse Fast Fourier Transform with outputs in bit reversed order.\nFFT is done in place along the last dimension where the size is required to be a power of 2.\nFollows a procedure described in https://www.expertsmind.com/learning/inverse-dft-using-the-fft-algorithm-assignment-help-7342873886.aspx.\n\nArgs:\n    d1 (np.uint64): first dimension\n    d2 (np.uint64): second dimension\n    n_half (np.uint64): half of the last dimension of size n = 2n_half along which FFT is performed\n    twiddler (np.ndarray of np.double): size n vector used to store real twiddle factors\n    twiddlei (np.ndarray of np.double): size n vector used to store imaginary twiddle factors \n    xr (np.ndarray of np.double): real array of size d1*d2*n on which to perform FFT in place\n    xi (np.ndarray of np.double): imaginary array of size d1*d2*n on which to perform FFT in place\n&gt;&gt;&gt; d1 = np.uint64(1) \n&gt;&gt;&gt; d2 = np.uint64(1)\n&gt;&gt;&gt; xr = np.array([1,0,1,0,0,1,1,0],dtype=np.double)\n&gt;&gt;&gt; xi = np.array([0,1,0,1,1,0,0,1],dtype=np.double)\n&gt;&gt;&gt; xr_og = xr.copy()\n&gt;&gt;&gt; xi_og = xi.copy()\n&gt;&gt;&gt; twiddler = np.empty_like(xr,dtype=np.double)\n&gt;&gt;&gt; twiddlei = np.empty_like(xr,dtype=np.double)\n&gt;&gt;&gt; n_half = np.uint64(len(xr)//2)\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.fft_bro_1d_radix2(d1,d2,n_half,twiddler,twiddlei,xr,xi,**kwargs_ft)\n&gt;&gt;&gt; xr\narray([ 1.41421356, -0.5       ,  0.        ,  1.20710678,  0.        ,\n        0.5       ,  0.        ,  0.20710678])\n&gt;&gt;&gt; xi\narray([ 1.41421356, -0.20710678,  0.        , -0.5       ,  0.        ,\n       -1.20710678,  0.        ,  0.5       ])\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.ifft_bro_1d_radix2(d1,d2,n_half,twiddler,twiddlei,xr,xi,**kwargs_ft)\n&gt;&gt;&gt; np.allclose(xr,xr_og,atol=1e-8)\nTrue\n&gt;&gt;&gt; np.allclose(xi,xi_og,atol=1e-8)\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; d1 = np.uint(5) \n&gt;&gt;&gt; d2 = np.uint(7) \n&gt;&gt;&gt; m = 8\n&gt;&gt;&gt; n = 2**m\n&gt;&gt;&gt; n_half = np.uint(n//2)\n&gt;&gt;&gt; bitrev = np.vectorize(lambda i,m: int('{:0{m}b}'.format(i,m=m)[::-1],2))\n&gt;&gt;&gt; ir = bitrev(np.arange(n),m) \n&gt;&gt;&gt; xr = rng.uniform(0,1,(d1,d2,int(2*n_half))).astype(np.double)\n&gt;&gt;&gt; xi = rng.uniform(0,1,(d1,d2,int(2*n_half))).astype(np.double)\n&gt;&gt;&gt; twiddler = np.empty_like(xr,dtype=np.double)\n&gt;&gt;&gt; twiddlei = np.empty_like(xr,dtype=np.double)\n&gt;&gt;&gt; x_np = xr+1j*xi\n&gt;&gt;&gt; x_bro_np = x_np[:,:,ir]\n&gt;&gt;&gt; y = xr+1j*xi\n&gt;&gt;&gt; yt_np = np.fft.fft(x_bro_np,norm=\"ortho\")\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.fft_bro_1d_radix2(d1,d2,n_half,twiddler,twiddlei,xr,xi,**kwargs_ft)\n&gt;&gt;&gt; yt = xr+1j*xi\n&gt;&gt;&gt; np.allclose(yt,yt_np,atol=1e-8)\nTrue\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.ifft_bro_1d_radix2(d1,d2,n_half,twiddler,twiddlei,xr,xi,**kwargs_ft)\n&gt;&gt;&gt; np.allclose(xr+1j*xi,y,atol=1e-8)\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; fft_np = lambda x: np.fft.fft(x,norm=\"ortho\")\n&gt;&gt;&gt; ifft_np = lambda x: np.fft.ifft(x,norm=\"ortho\")\n&gt;&gt;&gt; def fft(x):\n...     assert x.ndim==1\n...     n = len(x)\n...     n_half = np.uint64(n//2)\n...     xr = x.real.copy()\n...     xi = x.imag.copy()\n...     qmctoolscl.fft_bro_1d_radix2(1,1,n_half,np.empty(n,dtype=np.double),np.empty(n,dtype=np.double),xr,xi)\n...     return xr+1j*xi\n&gt;&gt;&gt; def ifft(x):\n...     assert x.ndim==1\n...     n = len(x)\n...     n_half = np.uint64(n//2)\n...     xr = x.real.copy()\n...     xi = x.imag.copy()\n...     qmctoolscl.ifft_bro_1d_radix2(1,1,n_half,np.empty(n,dtype=np.double),np.empty(n,dtype=np.double),xr,xi)\n...     return xr+1j*xi\n&gt;&gt;&gt; # parameters \n&gt;&gt;&gt; m = 10\n&gt;&gt;&gt; n = 2**m\n&gt;&gt;&gt; # bit reverse used for reference solver \n&gt;&gt;&gt; bitrev = np.vectorize(lambda i,m: int('{:0{m}b}'.format(i,m=m)[::-1],2))\n&gt;&gt;&gt; ir = bitrev(np.arange(2*n),m+1)\n&gt;&gt;&gt; # points \n&gt;&gt;&gt; y1 = np.random.rand(n)+1j*np.random.rand(n)\n&gt;&gt;&gt; y2 = np.random.rand(n)+1j*np.random.rand(n)\n&gt;&gt;&gt; y = np.hstack([y1,y2])\n&gt;&gt;&gt; # kernel evaluations\n&gt;&gt;&gt; k1 = np.random.rand(n) \n&gt;&gt;&gt; k2 = np.random.rand(n) \n&gt;&gt;&gt; k = np.hstack([k1,k2]) \n&gt;&gt;&gt; # fast transforms \n&gt;&gt;&gt; yt = fft(y) \n&gt;&gt;&gt; kt = fft(k)\n&gt;&gt;&gt; y1t = fft(y1) \n&gt;&gt;&gt; y2t = fft(y2) \n&gt;&gt;&gt; k1t = fft(k1) \n&gt;&gt;&gt; k2t = fft(k2)\n&gt;&gt;&gt; wt = np.exp(-np.pi*1j*np.arange(n)/n)\n&gt;&gt;&gt; wtsq = wt**2\n&gt;&gt;&gt; gammat = k1t**2-wtsq*k2t**2\n&gt;&gt;&gt; # matrix vector product\n&gt;&gt;&gt; u = ifft(yt*kt)*np.sqrt(2*n)\n&gt;&gt;&gt; u_np = ifft_np(fft_np(y[ir])*fft_np(k[ir]))[ir]*np.sqrt(2*n)\n&gt;&gt;&gt; np.allclose(u,u_np,atol=1e-10)\nTrue\n&gt;&gt;&gt; u_hat = np.hstack([ifft(y1t*k1t+wtsq*y2t*k2t),ifft(y2t*k1t+y1t*k2t)])*np.sqrt(n)\n&gt;&gt;&gt; np.allclose(u_hat,u,atol=1e-10)\nTrue\n&gt;&gt;&gt; # inverse \n&gt;&gt;&gt; v = ifft(yt/kt)/np.sqrt(2*n)\n&gt;&gt;&gt; v_np = ifft_np(fft_np(y[ir])/fft_np(k[ir]))[ir]/np.sqrt(2*n)\n&gt;&gt;&gt; np.allclose(v,v_np,atol=1e-10)\nTrue\n&gt;&gt;&gt; v_hat = np.hstack([ifft((y1t*k1t-wtsq*y2t*k2t)/gammat),ifft((y2t*k1t-y1t*k2t)/gammat)])/np.sqrt(n)\n&gt;&gt;&gt; np.allclose(v,v_hat,atol=1e-10)\nTrue\n</code></pre>"},{"location":"#fast-walsh-hadamard-transform","title":"fast Walsh-Hadamard transform","text":"<pre><code>&gt;&gt;&gt; print(qmctoolscl.fwht_1d_radix2.__doc__)\nFast Walsh-Hadamard Transform for real valued inputs.\nFWHT is done in place along the last dimension where the size is required to be a power of 2.\nFollows the divide-and-conquer algorithm described in https://en.wikipedia.org/wiki/Fast_Walsh%E2%80%93Hadamard_transform\n\nArgs:\n    d1 (np.uint64): first dimension\n    d2 (np.uint64): second dimension\n    n_half (np.uint64): half of the last dimension along which FWHT is performed\n    x (np.ndarray of np.double): array of size d1*d2*2n_half on which to perform FWHT in place\n&gt;&gt;&gt; d1 = np.uint64(1) \n&gt;&gt;&gt; d2 = np.uint64(1)\n&gt;&gt;&gt; x = np.array([1,0,1,0,0,1,1,0],dtype=np.double)\n&gt;&gt;&gt; n_half = np.uint64(len(x)//2)\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.fwht_1d_radix2(d1,d2,n_half,x,**kwargs_ft)\n&gt;&gt;&gt; x\narray([ 1.41421356,  0.70710678,  0.        , -0.70710678,  0.        ,\n        0.70710678,  0.        ,  0.70710678])\n</code></pre> <pre><code>&gt;&gt;&gt; d1 = np.uint(5) \n&gt;&gt;&gt; d2 = np.uint(7)\n&gt;&gt;&gt; n = 2**8\n&gt;&gt;&gt; n_half = np.uint(n//2) \n&gt;&gt;&gt; x = rng.uniform(0,1,(d1,d2,int(2*n_half))).astype(np.double)\n&gt;&gt;&gt; x_og = x.copy()\n&gt;&gt;&gt; import sympy\n&gt;&gt;&gt; y_sympy = np.empty_like(x,dtype=np.double) \n&gt;&gt;&gt; for i in range(d1):\n...     for j in range(d2): \n...         y_sympy[i,j] = np.array(sympy.fwht(x[i,j])/np.sqrt(n),dtype=np.double)\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.fwht_1d_radix2(d1,d2,n_half,x,**kwargs_ft)\n&gt;&gt;&gt; np.allclose(x,y_sympy,atol=1e-8)\nTrue\n&gt;&gt;&gt; time_perf,time_process = qmctoolscl.fwht_1d_radix2(d1,d2,n_half,x,**kwargs_ft)\n&gt;&gt;&gt; np.allclose(x,x_og,atol=1e-8)\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; def fwht_sp(x):\n...     assert x.ndim==1\n...     n = len(x) \n...     y = np.array(sympy.fwht(x),dtype=np.float64)\n...     y_ortho = y/np.sqrt(n) \n...     return y_ortho\n&gt;&gt;&gt; def fwht(x):\n...     assert x.ndim==1\n...     n = len(x)\n...     n_half = np.uint64(n//2)\n...     x_cp = x.copy()\n...     qmctoolscl.fwht_1d_radix2(1,1,n_half,x_cp)\n...     return x_cp\n&gt;&gt;&gt; # parameters\n&gt;&gt;&gt; m = 10\n&gt;&gt;&gt; n = int(2**m)\n&gt;&gt;&gt; # points\n&gt;&gt;&gt; y1 = np.random.rand(n) \n&gt;&gt;&gt; y2 = np.random.rand(n) \n&gt;&gt;&gt; y = np.hstack([y1,y2])\n&gt;&gt;&gt; # kernel evaluations\n&gt;&gt;&gt; k1 = np.random.rand(n) \n&gt;&gt;&gt; k2 = np.random.rand(n) \n&gt;&gt;&gt; k = np.hstack([k1,k2]) \n&gt;&gt;&gt; # fast transforms\n&gt;&gt;&gt; yt = fwht(y) \n&gt;&gt;&gt; kt = fwht(k)\n&gt;&gt;&gt; y1t = fwht(y1) \n&gt;&gt;&gt; y2t = fwht(y2) \n&gt;&gt;&gt; k1t = fwht(k1) \n&gt;&gt;&gt; k2t = fwht(k2)\n&gt;&gt;&gt; gammat = k1t**2-k2t**2\n&gt;&gt;&gt; # matrix vector product\n&gt;&gt;&gt; u_sp = fwht_sp(fwht_sp(y)*fwht_sp(k))*np.sqrt(2*n)\n&gt;&gt;&gt; u = fwht(yt*kt)*np.sqrt(2*n)\n&gt;&gt;&gt; np.allclose(u_sp,u,atol=1e-8)\nTrue\n&gt;&gt;&gt; u_hat = np.hstack([fwht(y1t*k1t+y2t*k2t),fwht(y2t*k1t+y1t*k2t)])*np.sqrt(n)\n&gt;&gt;&gt; np.allclose(u,u_hat,atol=1e-10)\nTrue\n&gt;&gt;&gt; # inverse \n&gt;&gt;&gt; v_sp = fwht_sp(fwht_sp(y)/fwht_sp(k))/np.sqrt(2*n)\n&gt;&gt;&gt; v = fwht(yt/kt)/np.sqrt(2*n)\n&gt;&gt;&gt; np.allclose(v_sp,v,atol=1e-8)\nTrue\n&gt;&gt;&gt; v_hat = np.hstack([fwht((y1t*k1t-y2t*k2t)/gammat),fwht((y2t*k1t-y1t*k2t)/gammat)])/np.sqrt(n)\n&gt;&gt;&gt; np.allclose(v,v_hat,atol=1e-10)\nTrue\n</code></pre>"}]}